export async function GET() {
  const schemaSql = `-- Memoria Universal Core Schema (Postgres)
-- Idempotent: safe to run multiple times

-- =========================
-- Index buckets
-- =========================
CREATE TABLE IF NOT EXISTS public.memoria_indexes (
  id          bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  key         text NOT NULL UNIQUE,
  name        text NULL,
  description text NULL,
  created_at  timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS public.memoria_subindexes (
  id               bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  memoria_index_id  bigint NOT NULL REFERENCES public.memoria_indexes(id) ON DELETE CASCADE,
  key              text NOT NULL,
  name             text NULL,
  description      text NULL,
  created_at       timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (memoria_index_id, key)
);

-- =========================
-- Conversations (threads)
-- =========================
CREATE TABLE IF NOT EXISTS public.memoria_threads (
  id                 bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  external_id         text NOT NULL UNIQUE,
  app_source          text NOT NULL DEFAULT 'unknown',
  title               text NULL,
  context             text NULL,
  memoria_index_id    bigint NULL REFERENCES public.memoria_indexes(id) ON DELETE SET NULL,
  memoria_subindex_id bigint NULL REFERENCES public.memoria_subindexes(id) ON DELETE SET NULL,
  metadata            jsonb DEFAULT '{}'::jsonb,
  created_at          timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
  updated_at          timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
  last_turn_at        timestamp without time zone NULL
);

-- =========================
-- Turns (messages/records)
-- =========================
CREATE TABLE IF NOT EXISTS public.memoria_turns (
  id                         bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  thread_id                  bigint NOT NULL REFERENCES public.memoria_threads(id) ON DELETE CASCADE,
  external_turn_id           text NULL,
  turn_index                 integer NOT NULL,
  user_text                  text NULL,
  assistant_thinking_summary text NULL,
  assistant_synthesis        text NULL,
  code_summary               text NULL,
  assistant_response         text NULL,
  raw_messages               jsonb NULL,
  metadata                   jsonb DEFAULT '{}'::jsonb,
  created_at                 timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (thread_id, turn_index),
  UNIQUE (thread_id, external_turn_id)
);

-- =========================
-- Indexes (performance)
-- =========================
CREATE INDEX IF NOT EXISTS idx_memoria_threads_source ON public.memoria_threads (app_source);
CREATE INDEX IF NOT EXISTS idx_memoria_threads_updated_at ON public.memoria_threads (updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_memoria_threads_last_turn_at ON public.memoria_threads (last_turn_at DESC);
CREATE INDEX IF NOT EXISTS idx_memoria_threads_index_subindex ON public.memoria_threads (memoria_index_id, memoria_subindex_id);

CREATE INDEX IF NOT EXISTS idx_memoria_turns_thread_created_at ON public.memoria_turns (thread_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_memoria_turns_external_turn_id ON public.memoria_turns (external_turn_id) WHERE (external_turn_id IS NOT NULL);

-- Full-text search across turn content
CREATE INDEX IF NOT EXISTS idx_memoria_turns_search ON public.memoria_turns
USING gin (to_tsvector('english',
  (COALESCE(user_text,'') || ' ' ||
   COALESCE(assistant_response,'') || ' ' ||
   COALESCE(assistant_synthesis,'') || ' ' ||
   COALESCE(code_summary,''))
));
`;

  return Response.json({
    name: "Memoria Universal Integration",
    version: "1.1",
    goals: [
      "Capture conversations (turn-by-turn) from any app (web, mobile, backend)",
      "Provide a single homogenous schema for AI memory: indexes → threads → turns",
      "Support a 5-layer turn record: question, thinking summary, synthesis, code summary, final response",
      "Make ingestion universal: any AI, any app, any stack can write to the same model",
    ],

    defaults: {
      index: "Cross_App_Conversations",
      subindex: "<appSource>",
      note: "If you omit index/subindex when capturing, the hub will file it under Cross_App_Conversations > <appSource>.",
    },

    identity: {
      canonical_thread_id: {
        field: "externalId",
        stored_as: "memoria_threads.external_id",
        recommended_format: "<appSource>:<threadId>",
        examples: ["ditzl:chat-123", "rosebud:ticket-88"],
      },
      canonical_turn_id: {
        field: "turn.externalTurnId",
        stored_as: "memoria_turns.external_turn_id",
        recommended_format: "<externalId>:<turnIndex>",
        examples: ["ditzl:chat-123:0", "ditzl:chat-123:1"],
      },
      ordering: {
        field: "turn.turnIndex",
        note: "0-based recommended. If omitted, the server appends using next available turn_index.",
      },
    },

    auth: {
      scheme: "Bearer token",
      header: "Authorization: Bearer memoria.<tokenId>.<secret>",
      notes: [
        "Use /memoria/keys (admin) to create tokens.",
        "Token permissions control read/write.",
        "Token app_source is enforced server-side (no impersonation).",
      ],
    },

    endpoints: {
      capture: {
        method: "POST",
        path: "/api/memoria/external/capture",
        body_shape: {
          externalId: "string (recommended globally unique)",
          title: "string?",
          context: "string?",
          index: "string?",
          subindex: "string? (ignored; server forces to token app_source)",
          turn: {
            externalTurnId: "string? (recommended for idempotency)",
            turnIndex: "number?",
            userText: "string?",
            assistantThinkingSummary: "string?",
            assistantSynthesis: "string?",
            codeSummary: "string?",
            assistantResponse: "string?",
            rawMessages: "array?",
            metadata: "object?",
          },
        },
      },
      search: {
        method: "GET",
        path: "/api/memoria/external/search?q=<query>&limit=<n>",
        note: "Search is scoped to token app_source.",
      },
      export_conversations: {
        method: "GET",
        path: "/api/memoria/export/conversations?since=<iso>&limit=<n>",
        description:
          "Batch pull conversations in normalized universal format (for hubs / replication).",
      },
    },

    schema: {
      sql: schemaSql,
      tables: [
        "memoria_indexes",
        "memoria_subindexes",
        "memoria_threads",
        "memoria_turns",
      ],
      relationship_graph: {
        memoria_indexes: "1 → many memoria_subindexes",
        memoria_indexes_to_threads: "optional (thread can point to index)",
        memoria_subindexes_to_threads:
          "optional (thread can point to subindex)",
        memoria_threads: "1 → many memoria_turns",
      },
    },

    copy_paste_client_snippet: {
      js: {
        name: "memoriaClient",
        note: "Copy/paste into any Node/React/Next app (server-side recommended).",
        example:
          "const client = createMemoriaClient({ baseUrl: 'https://YOUR-HUB.com', token: process.env.MEMORIA_BEARER_TOKEN }); await client.captureTurn({ externalId: 'ditzl:chat-123', title: 'Chat', turn: { userText: 'hi', assistantResponse: 'hello' } });",
      },
    },
  });
}
